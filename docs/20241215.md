```
一个项目有多少人(确切的数，没有区间的说法)
至少有1个pm  项目经理  ba  产品经理
架构师，测试，运维，分析，实时开发与离线开发，前端UI
离线开发比实时的多   我的职位为 高级数据开发
```

#### kafka的为什么快
```
Kafka的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，因为寻址会比较消耗时间，但是实际上，Kafka的特性之一就是高吞吐率。

主要原因有两个
1、顺序写入
数据是以blocks的形式存储到磁盘中的，每个block都有一个地址，读写数据时是通过块地址找到数据的，随机I/O会导致频繁的磁盘寻址，从而影响读写速度。
2：零拷贝
减少不同内存地址的拷贝，从而通过减少cpu和内存的使用而提升性能，并增加吞吐量。
当数据从一个地方传输到另外一个地方的时候，传统的做法就是先将数据读到一个临时buffer中，然后再拷贝它到目的地，零拷贝就是为了消除中间步骤，允许直接将数据从源读目的地。

Kafka速度的秘诀在于，它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap提高I/O速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合sendfile直接暴力输出
```

FlinkCDC基于什么实现的
#### object中有哪些方法
```
1、 getClass()：获取类的class对象。
2、 hashCode:获取对象的hashCode值
3、 equals():比较对象是否相等，比较的是值和地址，子类可重写以自定义。
4、 clone()：克隆方法。
5、 toString():如果没有重写，应用对象将打印的是地址值。
6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
9、 finalize()：对象回收时调用
```

#### jvm进程，线程
```
jvm相当于一个虚拟的系统，可以划分为进程
(1)JVM是一份本地化的程序，本质上是可执行的文件，是静态的概念。程序运行起来成为进程，是动态的概念。
(2) java程序是跑在JVM上的，严格来讲，是跑在JVM实例上的，一个JVM实例其实就是JVM跑起来的进程，二者合起来称之为一个JAVA进程。
(3)各个JVM实例之间是相互隔离的。
(4)一般一个进程是一个java程序的实例。

进程：是并发执行的程序在执行过程中分配和管理资源的基本单位。
线程：线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。线程之间共用一个进程的内存空存空间(即jvm堆内存)，各个线程也有自己独立专有的内存空间(即jvm栈空间)。

```
#### datax的底层原理
```
datax运行流程
1、Job
在 DataX 中用来描述一个源端到一个目的端的同步作业，是 DataX 数据同步面向用户的最小业务单元。一个Job 对应 一个 JobContainer， JobContainer 负责 Job 的全局切分、调度、前置语句和后置语句等工作。

2、Task Group
一组 Task 的集合，根据 DataX 的公平分配策略，公平地分配 Task 到对应的 TaskGroup 中。一个 TaskGroup 对应一个 TaskGroupContainer，负责执行一组 Task。

3、Task
Job 的最小执行单元，一个 Job 可根据 Reader 端切分策略，且分成若干个 Task，以便于并发执行。

4、Job、Task Group、Task 三者之间的关系可以用如下图表示：
根据切分策略将一个 Job 切分成多个 Task，根据分配策略将多个 Task 组成一个 TaskGroup。
Channel 作为传输通道，即能充当缓冲层，同时还能对数据传输进行限流操作。


5、Transformer
DataX 的 transformer 模式同时还提供了强大的数据转换功能，DataX 默认提供了丰富的数据转换实现类，用户还可以根据项目自身需求，扩展数据转换。
```
#### sqoop的底层原理，默认是4个mr任务
```

```





