#### 广播流
```
数据需要在所有任务中保持一致且实时更新,所以会使用广播流
缺点：很重，走IO，每个任务间分发，影响效率
可以使用FlinkCDC代替，其中有个方法cachetime()设置时间，来定时抓取变更的数据
```

#### flume实现断点续传
```
把offset用文件存储起来，下次接着上次消费的地方就行读取
Channel：负责临时存储数据，Source会将读取到的信息临时存储在这里，根据存储方式的不同，有很多类Channel，例如基于内存的Channel、基于文件的Channel等。常用的Channel组件有：
1. Memory Channel：使用内存作为数据的存储。优点是效率高，因为就不涉及磁盘IO；缺点有两个：可能会丢数据，如果Flume的agent挂了，那么channel中的数据就丢失了；内存是有限的，会存在内存不够用的情况。9
2. File Channel：使用文件来作为数据的存储。优点是数据不会丢失；缺点是效率相对内存来说会有点慢，但是这个慢并没有我们想象中的那么慢，所以这个也是比较常用的一种Channel。
3. Spillable Memory Channel：使用内存和文件作为数据存储，即先把数据存到内存中，如果内存中数据达到阈值再flush到文件中。优点：解决了内存不够用的问题；缺点：还是存在数据丢失的风险。
4. Kafka Channel：直接把数据流向kafka，不会存在落盘，效率提高
```

#### 为什么一个文件块为128？
```
因为普通的机械硬盘读写速度为128，先固态硬盘速度大多能跟上，所以现在大多一个块设置为256
如果小于128m，内存占用率高，增加寻址时间
如果大于128m，无法利用多namenode的优势

OLTP  面向于事务，关系型数据库
OLAP  面向于分析，分析工具
```






